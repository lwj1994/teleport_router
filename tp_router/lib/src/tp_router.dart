import 'dart:async';
import 'package:flutter/widgets.dart';
import 'package:flutter/scheduler.dart';
import 'package:go_router/go_router.dart';
import 'package:tp_router_annotation/tp_router_annotation.dart';
import 'navigator_key_registry.dart';
import 'navi_key.dart';
import 'route.dart';
import 'route_observer.dart';
import 'tp_route_info.dart';
import 'page_factory.dart';

/// Main router class that wraps go_router with tp_router routes.
///
/// This class provides a simple interface to configure and use
/// the router with automatically generated routes.
///
/// **Usage Note**:
/// This router must be initialized **early** in your application lifecycle (e.g. in `main()`),
/// before any navigation actions are performed.
///
/// Example:
/// ```dart
/// void main() {
///   final router = TpRouter(
///     routes: [...], // Generated routes
///   );
///   runApp(MaterialApp.router(
///     routerConfig: router.routerConfig,
///   ));
/// }
/// ```
class TpRouter {
  /// The underlying go_router instance.
  final GoRouter _goRouter;

  /// The list of registered routes.
  final List<TpRouteBase> _routes;

  static TpRouter? _instance;

  /// Get the global router instance.
  ///
  /// This is available after the first call to the factory constructor.
  static TpRouter get instance {
    if (_instance == null) {
      throw FlutterError(
        'TpRouter has not been initialized. '
        'Ensure you create a TpRouter instance before accessing it.',
      );
    }
    return _instance!;
  }

  /// Check if TpRouter has been initialized.
  static bool get isInitialized => _instance != null;

  TpNavKey get navigatorKey => TpNavigatorKeyRegistry.rootKey;

  /// Creates a [TpRouter] from a list of [TpRouteBase].
  ///
  /// [routes] should be generated by build_runner or manually assembled.
  ///
  /// [errorBuilder] A custom error page builder.
  ///
  /// [redirect] A global redirection function. This is called for every navigation.
  /// Return a path string to redirect, or null to continue.
  ///
  /// [refreshListenable] A [Listenable] that triggers a refresh of the router
  /// (e.g. for authentication state changes).
  ///
  /// [redirectLimit] The maximum number of redirects allowed during a single
  /// navigation. Defaults to 5.
  ///
  /// [routerNeglect] Whether to ignore the browser history tracking.
  /// Defaults to false.
  ///
  /// [initialLocation] The initial location of the router. If not provided,
  /// it usually defaults to auto-detected initial route or `/`.
  ///
  /// [overridePlatformDefaultLocation] Whether to override the platform default
  /// initial location. Defaults to false.
  ///
  /// [initialExtra] The extra data to pass to the initial location.
  ///
  /// [observers] A list of [NavigatorObserver]s to monitor navigation events.
  /// Note: [TpRouteObserver] is automatically added for stack manipulation support.
  ///
  /// [debugLogDiagnostics] Whether to log diagnostic info to the console.
  /// Defaults to false.
  ///
  /// [navigatorKey] A global key for the root navigator.
  ///
  /// [restorationScopeId] An identifier for state restoration.
  ///
  /// [requestFocus] Whether the router should request focus associated with
  /// the current route. Defaults to true.
  ///
  /// [defaultTransition] Global default page transition builder.
  /// Used when a route does not specify its own transition.
  ///
  /// [defaultTransitionDuration] Global default transition duration.
  ///
  /// [defaultReverseTransitionDuration] Global default reverse transition duration.
  factory TpRouter({
    required List<TpRouteBase> routes,
    Widget Function(BuildContext, TpRouteData)? errorBuilder,
    FutureOr<TpRouteData?> Function(BuildContext context, TpRouteData state)?
        redirect,
    Listenable? refreshListenable,
    int redirectLimit = 5,
    bool routerNeglect = false,
    String? initialLocation,
    bool overridePlatformDefaultLocation = false,
    Object? initialExtra,
    TpRouterConfig? config,
    List<NavigatorObserver>? observers,
    bool debugLogDiagnostics = false,
    TpNavKey? navigatorKey,
    String? restorationScopeId,
    bool requestFocus = true,
    TpTransitionsBuilder? defaultTransition,
    Duration? defaultTransitionDuration,
    Duration? defaultReverseTransitionDuration,
    TpPageType? defaultPageType,
    TpPageFactory? defaultPageBuilder,
  }) {
    // Use the provided key or fall back to the global root key
    if (navigatorKey != null) {
      TpNavigatorKeyRegistry.rootKey = navigatorKey;
    }
    // Determine initial location logic
    // If initialLocation is provided by user, use it.
    // Otherwise, try to auto-detect from routes.
    String? startLoc = initialLocation;

    if (startLoc == null) {
      for (final route in routes) {
        final loc = _findInitialPath(route);
        if (loc != null) {
          startLoc = loc;
          break;
        }
      }

      // Default to '/' if no initial route found, or the first route's path if available
      if (startLoc == null && routes.isNotEmpty) {
        final first = routes.first;
        if (first is TpRouteInfo) {
          startLoc = first.path;
        }
      }
      startLoc ??= '/';
    }

    // Convert TpRouteBase to GoRoute/ShellRoute
    // Use provided config or construct from parameters
    final effectiveConfig = config ??
        TpRouterConfig(
          defaultTransition: defaultTransition,
          defaultTransitionDuration: defaultTransitionDuration,
          defaultReverseTransitionDuration: defaultReverseTransitionDuration,
          defaultPageType: defaultPageType,
          defaultPageBuilder: defaultPageBuilder,
        );

    final goRoutes =
        routes.map((r) => r.toGoRoute(config: effectiveConfig)).toList();

    // Automatically inject TpRouteObserver for stack manipulation support
    final allObservers = [
      TpNavigatorKeyRegistry.rootKey.observer,
      ...?observers, // User-provided observers come after
    ];

    final goRouter = GoRouter(
      routes: goRoutes,
      initialLocation: startLoc,
      initialExtra: initialExtra,
      errorBuilder: errorBuilder != null
          ? (context, state) => errorBuilder(context, _StateRouteData(state))
          : null,
      redirect: (context, state) async {
        if (redirect != null) {
          final target = await redirect(context, _StateRouteData(state));
          return target?.fullPath;
        }
        return null;
      },
      refreshListenable: refreshListenable,
      redirectLimit: redirectLimit,
      routerNeglect: routerNeglect,
      overridePlatformDefaultLocation: overridePlatformDefaultLocation,
      observers: allObservers, // ‚Üê Use combined observers with TpRouteObserver
      debugLogDiagnostics: debugLogDiagnostics,
      navigatorKey: TpNavigatorKeyRegistry.rootKey.globalKey,
      restorationScopeId: restorationScopeId,
      requestFocus: requestFocus,
    );

    _instance = TpRouter._(goRouter, routes);
    return _instance!;
  }

  static String? _findInitialPath(TpRouteBase route) {
    if (route is TpRouteInfo) {
      if (route.isInitial) return route.path;
    } else if (route is TpShellRouteInfo) {
      for (final child in route.routes) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpStatefulShellRouteInfo) {
      for (final branch in route.branches) {
        for (final child in branch) {
          final path = _findInitialPath(child);
          if (path != null) return path;
        }
      }
    }
    return null;
  }

  TpRouter._(this._goRouter, this._routes);

  /// Get the router configuration for MaterialApp.router().
  RouterConfig<Object> get routerConfig => _goRouter;

  /// Get the list of registered routes.
  List<TpRouteBase> get routes => List.unmodifiable(_routes);

  /// Get the route observer for stack manipulation.
  ///
  /// This is used internally by delete() method.
  TpRouteObserver get routeObserver => TpNavigatorKeyRegistry.rootKey.observer;

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///

  /// Example:
  /// ```dart
  /// // Push a new route
  /// router.tp(HomeRoute());
  ///
  /// // Replace current route
  /// router.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// router.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// router.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    // Determine which GoRouter instance to use
    final targetRouter = _goRouter;

    if (isClearHistory) {
      targetRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return targetRouter.pushReplacement<T>(route.fullPath,
          extra: route.extra);
    } else {
      return targetRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>({
    T? result,
  }) {
    if (canPop) {
      _goRouter.pop<T>(result);
    }
  }

  /// Check if can pop the current route.
  bool get canPop => _goRouter.canPop();

  /// Get the current location.
  TpRouteData location({TpNavKey? navigatorKey, BuildContext? context}) {
    final observer = getObserver(navigatorKey: navigatorKey, context: context);
    if (observer.allRouteData.isNotEmpty) {
      return observer.allRouteData.values.last;
    }
    return TpRouteData.fromPath('/');
  }

  /// Pop routes until the predicate is satisfied.
  ///
  /// The [predicate] callback is called for each route on the stack (from top to bottom).
  ///
  /// - [route]: The raw Flutter Route instance.
  /// - [data]: The associated [TpRouteData] if the route is managed by tp_router.
  ///         If the route is not managed by tp_router (e.g. standard Dialog), `data` will be null.
  ///
  /// Example:
  /// ```dart
  /// // Pop until we find the Home route
  /// router.popUntil((route, data) => data?.routeName == 'Home');
  /// ```
  void popUntil(
    bool Function(Route<dynamic> route, TpRouteData? data) predicate, {
    TpNavKey? navigatorKey,
    BuildContext? context,
  }) {
    final nav = context != null
        ? Navigator.of(context)
        : _getNavigator(navigatorKey: navigatorKey);
    final observer = _findObserverInNavigator(nav);

    // Iteratively check the top route and pop if predicate is not met
    while (observer.allRoutes.isNotEmpty) {
      final topRoute = observer.allRoutes.last;
      final data = observer.getRouteData(topRoute);

      if (predicate(topRoute, data)) {
        return; // Predicate satisfied, stop popping
      }

      if (topRoute.isFirst) {
        return; // Reached the first route, stop popping to avoid emptying stack
      }

      pop();
    }
  }

  /// Pop until the first route in the stack.
  void popToInitial({
    TpNavKey? navigatorKey,
    BuildContext? context,
  }) {
    popUntil((route, _) => route.isFirst,
        navigatorKey: navigatorKey, context: context);
  }

  /// Pop until the specified route is found.
  ///
  /// Matches by [TpRouteData.routeName] and [TpRouteData.fullPath].
  void popTo(
    TpRouteData route, {
    TpNavKey? navigatorKey,
    BuildContext? context,
  }) {
    popUntil((r, data) => data == route,
        navigatorKey: navigatorKey, context: context);
  }

  /// Remove a route from the navigation stack.
  bool removeRoute(
    TpRouteData route, {
    TpNavKey? navigatorKey,
  }) {
    return removeWhere(
          (data) =>
              data.routeName == route.routeName &&
              data.fullPath == route.fullPath,
          navigatorKey: navigatorKey,
        ) >
        0;
  }

  /// Remove all routes that match the given predicate.
  int removeWhere(
    bool Function(TpRouteData data) predicate, {
    TpNavKey? navigatorKey,
  }) {
    final observer = _findObserverInNavigator(_getNavigator(
      navigatorKey: navigatorKey,
    ));

    final routesToRemove = <Route>[];
    for (final route in observer.allRoutes) {
      final data = observer.getRouteData(route);
      if (data != null && predicate(data)) {
        routesToRemove.add(route);
      }
    }

    SchedulerBinding.instance.addPostFrameCallback((_) {
      for (final route in routesToRemove) {
        if (route.isCurrent) {
          // If current, just pop
          pop();
        } else {
          // If not current, mark for removal so it gets popped when revealed
          observer.markRouteForRemoval(route);
        }
      }
    });

    return routesToRemove.length;
  }

  /// Get the route observer for tracking navigation stack.
  TpRouteObserver getObserver({
    TpNavKey? navigatorKey,
    BuildContext? context,
  }) {
    if (context != null) {
      return _findObserverInNavigator(_getNavigator(
        context: context,
      ));
    }
    return (navigatorKey ?? TpNavigatorKeyRegistry.rootKey).observer;
  }

  /// Internal helper to get NavigatorState.
  ///
  /// Logic:
  /// 1. If navigatorKey is provided and found, use it.
  /// 2. Otherwise (navigatorKey null/not found), use root.
  NavigatorState _getNavigator(
      {TpNavKey? navigatorKey, BuildContext? context}) {
    if (context != null) return Navigator.of(context);
    // Try navigatorKey first
    if (navigatorKey != null) {
      final key = navigatorKey.globalKey;
      if (key.currentState != null) return key.currentState!;
      throw FlutterError(
        'Navigator for $navigatorKey is not mounted yet. '
        'Ensure the Navigator widget associated with this key is in the widget tree.',
      );
    }
    // Fallback to root
    return TpNavigatorKeyRegistry.rootKey.globalKey.currentState!;
  }

  TpRouteObserver _findObserverInNavigator(NavigatorState navigator) {
    final observer = _searchObservers(navigator.widget.observers);
    if (observer != null) return observer;
    throw FlutterError(
      'TpRouteObserver not found in Navigator. '
      'This is required for tp_router to function properly. '
      'Ensure you are using TpRouter or manually adding TpRouteObserver to your Navigator.',
    );
  }

  TpRouteObserver? _searchObservers(List<NavigatorObserver> observers) {
    for (final observer in observers) {
      if (observer is TpRouteObserver) return observer;
      try {
        final dynamic dynamicObserver = observer;
        final children = dynamicObserver.observers;
        if (children is List<NavigatorObserver>) {
          final found = _searchObservers(children);
          if (found != null) return found;
        }
      } catch (_) {}
    }
    return null;
  }

  /// Dispose the router.
  void dispose() {
    _goRouter.dispose();
  }
}

/// Internal implementation of TpRouteData that wraps GoRouterState.
class _StateRouteData extends TpRouteData {
  final GoRouterState _state;

  const _StateRouteData(this._state);

  @override
  String? get routeName => _state.name;

  @override
  String get fullPath => _state.uri.toString();

  @override
  Uri get uri => _state.uri;

  @override
  Map<String, String> get pathParams => _state.pathParameters;

  @override
  Map<String, String> get queryParams => _state.uri.queryParameters;

  @override
  Map<String, dynamic> get extra {
    final e = _state.extra;
    if (e is Map<String, dynamic>) {
      return e;
    }
    return const {};
  }

  @override
  Object? get error => _state.error;
}
