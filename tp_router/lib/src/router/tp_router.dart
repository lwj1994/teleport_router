import 'package:flutter/widgets.dart';
import 'package:go_router/go_router.dart';
import 'package:tp_router_annotation/tp_router_annotation.dart';
import 'route.dart';
import 'tp_route_info.dart';

/// Main router class that wraps go_router with tp_router routes.
///
/// This class provides a simple interface to configure and use
/// the router with automatically generated routes.
class TpRouter {
  /// The underlying go_router instance.
  final GoRouter _goRouter;

  /// The list of registered routes.
  final List<TpRouteBase> _routes;

  /// Creates a [TpRouter] from a list of [TpRouteBase].
  ///
  /// [routes] should be generated by build_runner or manually assembled.
  ///
  /// [errorBuilder] A custom error page builder.
  ///
  /// [redirect] A global redirection function. This is called for every navigation.
  /// Return a path string to redirect, or null to continue.
  ///
  /// [refreshListenable] A [Listenable] that triggers a refresh of the router
  /// (e.g. for authentication state changes).
  ///
  /// [redirectLimit] The maximum number of redirects allowed during a single
  /// navigation. Defaults to 5.
  ///
  /// [routerNeglect] Whether to ignore the browser history tracking.
  /// Defaults to false.
  ///
  /// [initialLocation] The initial location of the router. If not provided,
  /// it usually defaults to auto-detected initial route or `/`.
  ///
  /// [overridePlatformDefaultLocation] Whether to override the platform default
  /// initial location. Defaults to false.
  ///
  /// [initialExtra] The extra data to pass to the initial location.
  ///
  /// [observers] A list of [NavigatorObserver]s to monitor navigation events.
  ///
  /// [debugLogDiagnostics] Whether to log diagnostic info to the console.
  /// Defaults to false.
  ///
  /// [navigatorKey] A global key for the root navigator.
  ///
  /// [restorationScopeId] An identifier for state restoration.
  ///
  /// [requestFocus] Whether the router should request focus associated with
  /// the current route. Defaults to true.
  ///
  /// [defaultTransition] Global default page transition builder.
  /// Used when a route does not specify its own transition.
  ///
  /// [defaultTransitionDuration] Global default transition duration.
  ///
  /// [defaultReverseTransitionDuration] Global default reverse transition duration.
  factory TpRouter({
    required List<TpRouteBase> routes,
    Widget Function(BuildContext, TpRouteData)? errorBuilder,
    String? Function(BuildContext, TpRouteData)? redirect,
    Listenable? refreshListenable,
    int redirectLimit = 5,
    bool routerNeglect = false,
    String? initialLocation,
    bool overridePlatformDefaultLocation = false,
    Object? initialExtra,
    List<NavigatorObserver>? observers,
    bool debugLogDiagnostics = false,
    GlobalKey<NavigatorState>? navigatorKey,
    String? restorationScopeId,
    bool requestFocus = true,
    TpTransitionsBuilder? defaultTransition,
    Duration? defaultTransitionDuration,
    Duration? defaultReverseTransitionDuration,
  }) {
    // Determine initial location logic
    // If initialLocation is provided by user, use it.
    // Otherwise, try to auto-detect from routes.
    String? startLoc = initialLocation;

    if (startLoc == null) {
      for (final route in routes) {
        final loc = _findInitialPath(route);
        if (loc != null) {
          startLoc = loc;
          break;
        }
      }

      // Default to '/' if no initial route found, or the first route's path if available
      if (startLoc == null && routes.isNotEmpty) {
        final first = routes.first;
        if (first is TpRouteInfo) {
          startLoc = first.path;
        }
      }
      startLoc ??= '/';
    }

    // Convert TpRouteBase to GoRoute/ShellRoute
    final config = TpRouterConfig(
      defaultTransition: defaultTransition,
      defaultTransitionDuration: defaultTransitionDuration,
      defaultReverseTransitionDuration: defaultReverseTransitionDuration,
    );

    final goRoutes = routes.map((r) => r.toGoRoute(config: config)).toList();

    final goRouter = GoRouter(
      routes: goRoutes,
      initialLocation: startLoc,
      initialExtra: initialExtra,
      errorBuilder: errorBuilder != null
          ? (context, state) => errorBuilder(context, _StateRouteData(state))
          : null,
      redirect: redirect != null
          ? (context, state) => redirect(context, _StateRouteData(state))
          : null,
      refreshListenable: refreshListenable,
      redirectLimit: redirectLimit,
      routerNeglect: routerNeglect,
      overridePlatformDefaultLocation: overridePlatformDefaultLocation,
      observers: observers,
      debugLogDiagnostics: debugLogDiagnostics,
      navigatorKey: navigatorKey,
      restorationScopeId: restorationScopeId,
      requestFocus: requestFocus,
    );

    return TpRouter._(goRouter, routes);
  }

  static String? _findInitialPath(TpRouteBase route) {
    if (route is TpRouteInfo) {
      if (route.isInitial) return route.path;
      for (final child in route.children) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpShellRouteInfo) {
      for (final child in route.routes) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpStatefulShellRouteInfo) {
      for (final branch in route.branches) {
        for (final child in branch) {
          final path = _findInitialPath(child);
          if (path != null) return path;
        }
      }
    }
    return null;
  }

  TpRouter._(this._goRouter, this._routes);

  /// Get a [TpRouterContext] from the given [BuildContext].
  ///
  /// This is similar to `GoRouter.of(context)` but returns a TpRouter API.
  ///
  /// Example:
  /// ```dart
  /// TpRouter.of(context).tp(HomeRoute());
  /// TpRouter.of(context).pop();
  /// ```
  static TpRouterContext of(BuildContext context) => TpRouterContext(context);

  /// Access the underlying [GoRouter] instance.
  GoRouter get goRouter => _goRouter;

  /// Get the router configuration for MaterialApp.router().
  RouterConfig<Object> get routerConfig => _goRouter;

  /// Get the list of registered routes.
  List<TpRouteBase> get routes => List.unmodifiable(_routes);

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///
  /// Example:
  /// ```dart
  /// // Push a new route
  /// router.tp(HomeRoute());
  ///
  /// // Replace current route
  /// router.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// router.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// router.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    if (isClearHistory) {
      _goRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return _goRouter.pushReplacement<T>(route.fullPath, extra: route.extra);
    } else {
      return _goRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    _goRouter.pop(result);
  }

  /// Check if can pop the current route.
  bool canPop() => _goRouter.canPop();

  /// Get the current location.
  String get location => _goRouter.routerDelegate.currentConfiguration.fullPath;

  /// Dispose the router.
  void dispose() {
    _goRouter.dispose();
  }
}

/// Context-bound router accessor for navigation.
///
/// This provides a convenient API: `context.tpRouter.tp(route)`.
class TpRouterContext {
  final BuildContext _context;

  /// Creates a [TpRouterContext] bound to the given [context].
  TpRouterContext(this._context);

  GoRouter get _goRouter => GoRouter.of(_context);

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///
  /// Example:
  /// ```dart
  /// // Push a new route
  /// context.tpRouter.tp(HomeRoute());
  ///
  /// // Replace current route
  /// context.tpRouter.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// context.tpRouter.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// context.tpRouter.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    if (isClearHistory) {
      _goRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return _goRouter.pushReplacement<T>(route.fullPath, extra: route.extra);
    } else {
      return _goRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    if (!canPop) return;
    _goRouter.pop(result);
  }

  /// Pop routes until the predicate is satisfied.
  void popUntil(bool Function(Route<dynamic>) predicate) {
    if (canPop) {
      Navigator.of(_context, rootNavigator: false).popUntil(predicate);
    }
  }

  /// Check if can pop the current route.
  bool get canPop => _goRouter.canPop();

  /// Get the current location.
  String get currentFullPath =>
      _goRouter.routerDelegate.currentConfiguration.fullPath;
}

/// Extension on [BuildContext] for easy access to TpRouter.
///
/// Usage:
/// ```dart
/// context.tpRouter.tp(HomeRoute());
/// context.tpRouter.tp(TpRouteData.fromPath('/details'));
/// context.tpRouter.pop();
/// ```
extension TpRouterExtension on BuildContext {
  /// Access the TpRouter API from this context.
  ///
  /// Example:
  /// ```dart
  /// context.tpRouter.tp(UserRoute(id: 123));
  /// context.tpRouter.pop();
  /// ```
  TpRouterContext get tpRouter => TpRouterContext(this);
}

/// Internal implementation of TpRouteData that wraps GoRouterState.
class _StateRouteData extends TpRouteData {
  final GoRouterState _state;

  const _StateRouteData(this._state);

  @override
  String get fullPath => _state.uri.toString();

  @override
  Uri get uri => _state.uri;

  @override
  Map<String, String> get pathParams => _state.pathParameters;

  @override
  Map<String, String> get queryParams => _state.uri.queryParameters;

  @override
  Map<String, dynamic> get extra {
    final e = _state.extra;
    if (e is Map<String, dynamic>) {
      return e;
    }
    return const {};
  }

  @override
  Object? get error => _state.error;
}
