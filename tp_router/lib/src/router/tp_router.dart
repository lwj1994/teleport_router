import 'package:flutter/widgets.dart';
import 'package:go_router/go_router.dart';
import 'tp_route_info.dart';

/// Main router class that wraps go_router with tp_router routes.
///
/// This class provides a simple interface to configure and use
/// the router with automatically generated routes.
class TpRouter {
  /// The underlying go_router instance.
  final GoRouter _goRouter;

  /// The list of registered routes.
  final List<TpRouteBase> _routes;

  /// Creates a [TpRouter] from a list of [TpRouteBase].
  ///
  /// [routes] should be generated by build_runner or manually assembled.
  /// [errorBuilder] optional custom error page builder.
  /// [redirect] optional global redirect function.
  /// [refreshListenable] optional listenable for refresh.
  factory TpRouter({
    required List<TpRouteBase> routes,
    Widget Function(BuildContext, GoRouterState)? errorBuilder,
    String? Function(BuildContext, GoRouterState)? redirect,
    Listenable? refreshListenable,
    List<NavigatorObserver>? observers,
  }) {
    // Determine initial location
    String? initialLocation;
    for (final route in routes) {
      final loc = _findInitialPath(route);
      if (loc != null) {
        initialLocation = loc;
        break;
      }
    }

    // Default to '/' if no initial route found, or the first route's path if available
    if (initialLocation == null && routes.isNotEmpty) {
      final first = routes.first;
      if (first is TpRouteInfo) {
        initialLocation = first.path;
      }
    }
    initialLocation ??= '/';

    // Convert TpRouteBase to GoRoute/ShellRoute
    final goRoutes = routes.map((r) => r.toGoRoute()).toList();

    final goRouter = GoRouter(
      routes: goRoutes,
      initialLocation: initialLocation,
      errorBuilder: errorBuilder,
      redirect: redirect,
      refreshListenable: refreshListenable,
      observers: observers,
    );

    return TpRouter._(goRouter, routes);
  }

  static String? _findInitialPath(TpRouteBase route) {
    if (route is TpRouteInfo) {
      if (route.isInitial) return route.path;
      for (final child in route.children) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpShellRouteInfo) {
      for (final child in route.routes) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpStatefulShellRouteInfo) {
      for (final branch in route.branches) {
        for (final child in branch) {
          final path = _findInitialPath(child);
          if (path != null) return path;
        }
      }
    }
    return null;
  }

  TpRouter._(this._goRouter, this._routes);

  /// Get a [TpRouterContext] from the given [BuildContext].
  ///
  /// This is similar to `GoRouter.of(context)` but returns a TpRouter API.
  ///
  /// Example:
  /// ```dart
  /// TpRouter.of(context).push('/user/123');
  /// TpRouter.of(context).pop();
  /// ```
  static TpRouterContext of(BuildContext context) => TpRouterContext(context);

  /// Access the underlying [GoRouter] instance.
  GoRouter get goRouter => _goRouter;

  /// Get the router configuration for MaterialApp.router().
  RouterConfig<Object> get routerConfig => _goRouter;

  /// Get the list of registered routes.
  List<TpRouteBase> get routes => List.unmodifiable(_routes);

  /// Navigate to a path (replaces navigation stack).
  void goPath(String path, {Object? extra}) {
    _goRouter.go(path, extra: extra);
  }

  /// Navigate to a route object.
  void go(TpRouteObject route) {
    _goRouter.go(route.fullPath, extra: route.extra);
  }

  /// Navigate to a named route.
  void goNamed(
    String name, {
    Map<String, String> pathParameters = const {},
    Map<String, String> queryParameters = const {},
    Object? extra,
  }) {
    _goRouter.goNamed(
      name,
      pathParameters: pathParameters,
      queryParameters: queryParameters,
      extra: extra,
    );
  }

  /// Push a path onto the navigation stack.
  Future<T?> pushPath<T extends Object?>(String path, {Object? extra}) {
    return _goRouter.push(path, extra: extra);
  }

  /// Push a route object onto the navigation stack.
  Future<T?> push<T extends Object?>(TpRouteObject route) {
    return _goRouter.push(route.fullPath, extra: route.extra);
  }

  /// Push a named route onto the navigation stack.
  Future<T?> pushNamed<T extends Object?>(
    String name, {
    Map<String, String> pathParameters = const {},
    Map<String, String> queryParameters = const {},
    Object? extra,
  }) {
    return _goRouter.pushNamed(
      name,
      pathParameters: pathParameters,
      queryParameters: queryParameters,
      extra: extra,
    );
  }

  /// Push a path and remove current route.
  Future<T?> pushReplacementPath<T extends Object?>(String path,
      {Object? extra}) {
    return _goRouter.pushReplacement(path, extra: extra);
  }

  /// Push a route object and remove current route.
  Future<T?> pushReplacement<T extends Object?>(TpRouteObject route) {
    return _goRouter.pushReplacement(route.fullPath, extra: route.extra);
  }

  /// Push a named route and remove current route.
  Future<T?> pushReplacementNamed<T extends Object?>(
    String name, {
    Map<String, String> pathParameters = const {},
    Map<String, String> queryParameters = const {},
    Object? extra,
  }) {
    return _goRouter.pushReplacementNamed(
      name,
      pathParameters: pathParameters,
      queryParameters: queryParameters,
      extra: extra,
    );
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    _goRouter.pop(result);
  }

  /// Check if can pop the current route.
  bool canPop() => _goRouter.canPop();

  /// Get the current location.
  String get location => _goRouter.routerDelegate.currentConfiguration.fullPath;

  /// Dispose the router.
  void dispose() {
    _goRouter.dispose();
  }
}

/// Context-bound router accessor for navigation.
///
/// This provides a convenient API: `context.tpRouter.push('/path')`.
class TpRouterContext {
  final BuildContext _context;

  /// Creates a [TpRouterContext] bound to the given [context].
  TpRouterContext(this._context);

  GoRouter get _goRouter => GoRouter.of(_context);

  /// Navigate to a path (replaces navigation stack).
  void goPath(String path, {Object? extra}) {
    _goRouter.go(path, extra: extra);
  }

  /// Navigate to a route object (replaces navigation stack).
  void go(TpRouteObject route) {
    _goRouter.go(route.fullPath, extra: route.extra);
  }

  Future<T?> pushPath<T extends Object?>(String path, {Object? extra}) {
    return _goRouter.push(path, extra: extra);
  }

  Future<T?> push<T extends Object?>(TpRouteObject route) {
    return _goRouter.push(route.fullPath, extra: route.extra);
  }

  /// Navigate to a named route.
  void goNamed(
    String name, {
    Map<String, String> pathParameters = const {},
    Map<String, String> queryParameters = const {},
    Object? extra,
  }) {
    _goRouter.goNamed(
      name,
      pathParameters: pathParameters,
      queryParameters: queryParameters,
      extra: extra,
    );
  }

  /// Push a named route onto the navigation stack.
  Future<T?> pushNamed<T extends Object?>(
    String name, {
    Map<String, String> pathParameters = const {},
    Map<String, String> queryParameters = const {},
    Object? extra,
  }) {
    return _goRouter.pushNamed(
      name,
      pathParameters: pathParameters,
      queryParameters: queryParameters,
      extra: extra,
    );
  }

  /// Push a path and remove current route.
  Future<T?> pushReplacementPath<T extends Object?>(String path,
      {Object? extra}) {
    return _goRouter.pushReplacement(path, extra: extra);
  }

  /// Push a route object and remove current route.
  Future<T?> pushReplacement<T extends Object?>(TpRouteObject route) {
    return _goRouter.pushReplacement(route.fullPath, extra: route.extra);
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    _goRouter.pop(result);
  }

  /// Pop routes until the predicate is satisfied.
  void popUntil(bool Function(Route<dynamic>) predicate) {
    if (_goRouter.canPop()) {
      Navigator.of(_context).popUntil(predicate);
    }
  }

  /// Check if can pop the current route.
  bool get canPop => _goRouter.canPop();

  /// Get the current location.
  String get currentFullPath =>
      _goRouter.routerDelegate.currentConfiguration.fullPath;
}

/// Extension on [BuildContext] for easy access to TpRouter.
///
/// Usage:
/// ```dart
/// context.tpRouter.go('/home');
/// context.tpRouter.push('/details', extra: {'id': 123});
/// context.tpRouter.pop();
/// ```
extension TpRouterExtension on BuildContext {
  /// Access the TpRouter API from this context.
  ///
  /// Example:
  /// ```dart
  /// context.tpRouter.push('/user/123');
  /// context.tpRouter.pop();
  /// ```
  TpRouterContext get tpRouter => TpRouterContext(this);
}

/// Extension on [BuildContext] for accessing route settings.
///
/// Usage:
/// ```dart
/// final id = context.tpRouteSettings.getIntRequired('id');
/// ```
extension TpRouteSettingsExtension on BuildContext {
  /// Access the current route's [TpRouteSettings].
  ///
  /// This extracts parameters from the current GoRouterState.
  TpRouteSettings get tpRouteSettings {
    final state = GoRouterState.of(this);
    return TpRouteSettings(
      pathParams: state.pathParameters,
      queryParams: state.uri.queryParameters,
      extra: state.extra,
    );
  }

  /// Get a String parameter from the current route.
  String? tpParam(String key) => tpRouteSettings.getString(key);

  /// Get a required String parameter from the current route.
  String tpParamRequired(String key) => tpRouteSettings.getStringRequired(key);

  /// Get an int parameter from the current route.
  int? tpParamInt(String key) => tpRouteSettings.getInt(key);

  /// Get a required int parameter from the current route.
  int tpParamIntRequired(String key) => tpRouteSettings.getIntRequired(key);

  /// Get a bool parameter from the current route.
  bool? tpParamBool(String key) => tpRouteSettings.getBool(key);

  /// Get extra data from the current route.
  T? tpExtra<T>(String key) => tpRouteSettings.getExtra<T>(key);

  /// Get the entire extra object from the current route.
  T? tpExtraAs<T>() => tpRouteSettings.getExtraAs<T>();
}
